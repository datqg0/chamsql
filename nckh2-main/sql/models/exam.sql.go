// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exam.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipant = `-- name: AddParticipant :one

INSERT INTO exam_participants (exam_id, user_id)
VALUES ($1, $2)
RETURNING id, exam_id, user_id, started_at, submitted_at, total_score, status, created_at
`

type AddParticipantParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

// =============================================
// EXAM PARTICIPANTS
// =============================================
func (q *Queries) AddParticipant(ctx context.Context, arg AddParticipantParams) (ExamParticipant, error) {
	row := q.db.QueryRow(ctx, addParticipant, arg.ExamID, arg.UserID)
	var i ExamParticipant
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.UserID,
		&i.StartedAt,
		&i.SubmittedAt,
		&i.TotalScore,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const addProblemToExam = `-- name: AddProblemToExam :one

INSERT INTO exam_problems (exam_id, problem_id, points, sort_order)
VALUES ($1, $2, $3, $4)
RETURNING id, exam_id, problem_id, points, sort_order
`

type AddProblemToExamParams struct {
	ExamID    int64  `json:"examId"`
	ProblemID int64  `json:"problemId"`
	Points    *int32 `json:"points"`
	SortOrder *int32 `json:"sortOrder"`
}

// =============================================
// EXAM PROBLEMS
// =============================================
func (q *Queries) AddProblemToExam(ctx context.Context, arg AddProblemToExamParams) (ExamProblem, error) {
	row := q.db.QueryRow(ctx, addProblemToExam,
		arg.ExamID,
		arg.ProblemID,
		arg.Points,
		arg.SortOrder,
	)
	var i ExamProblem
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.ProblemID,
		&i.Points,
		&i.SortOrder,
	)
	return i, err
}

const countUserExamSubmissions = `-- name: CountUserExamSubmissions :one
SELECT COUNT(*) FROM exam_submissions
WHERE exam_id = $1 AND exam_problem_id = $2 AND user_id = $3
`

type CountUserExamSubmissionsParams struct {
	ExamID        int64 `json:"examId"`
	ExamProblemID int64 `json:"examProblemId"`
	UserID        int64 `json:"userId"`
}

func (q *Queries) CountUserExamSubmissions(ctx context.Context, arg CountUserExamSubmissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserExamSubmissions, arg.ExamID, arg.ExamProblemID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExam = `-- name: CreateExam :one

INSERT INTO exams (
    title, description, created_by, start_time, end_time, duration_minutes,
    allowed_databases, allow_ai_assistance, shuffle_problems, 
    show_result_immediately, max_attempts, is_public, status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, description, created_by, start_time, end_time, duration_minutes, allowed_databases, allow_ai_assistance, shuffle_problems, show_result_immediately, max_attempts, is_public, status, created_at, updated_at
`

type CreateExamParams struct {
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
}

// =============================================
// EXAMS
// =============================================
func (q *Queries) CreateExam(ctx context.Context, arg CreateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, createExam,
		arg.Title,
		arg.Description,
		arg.CreatedBy,
		arg.StartTime,
		arg.EndTime,
		arg.DurationMinutes,
		arg.AllowedDatabases,
		arg.AllowAiAssistance,
		arg.ShuffleProblems,
		arg.ShowResultImmediately,
		arg.MaxAttempts,
		arg.IsPublic,
		arg.Status,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedBy,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.AllowedDatabases,
		&i.AllowAiAssistance,
		&i.ShuffleProblems,
		&i.ShowResultImmediately,
		&i.MaxAttempts,
		&i.IsPublic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createExamSubmission = `-- name: CreateExamSubmission :one

INSERT INTO exam_submissions (
    exam_id, exam_problem_id, user_id, code, database_type, status,
    execution_time_ms, expected_output, actual_output, error_message, 
    is_correct, score, attempt_number
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, exam_id, exam_problem_id, user_id, code, database_type, status, execution_time_ms, expected_output, actual_output, error_message, is_correct, score, attempt_number, submitted_at
`

type CreateExamSubmissionParams struct {
	ExamID          int64          `json:"examId"`
	ExamProblemID   int64          `json:"examProblemId"`
	UserID          int64          `json:"userId"`
	Code            string         `json:"code"`
	DatabaseType    string         `json:"databaseType"`
	Status          string         `json:"status"`
	ExecutionTimeMs *int32         `json:"executionTimeMs"`
	ExpectedOutput  []byte         `json:"expectedOutput"`
	ActualOutput    []byte         `json:"actualOutput"`
	ErrorMessage    *string        `json:"errorMessage"`
	IsCorrect       *bool          `json:"isCorrect"`
	Score           pgtype.Numeric `json:"score"`
	AttemptNumber   *int32         `json:"attemptNumber"`
}

// =============================================
// EXAM SUBMISSIONS
// =============================================
func (q *Queries) CreateExamSubmission(ctx context.Context, arg CreateExamSubmissionParams) (ExamSubmission, error) {
	row := q.db.QueryRow(ctx, createExamSubmission,
		arg.ExamID,
		arg.ExamProblemID,
		arg.UserID,
		arg.Code,
		arg.DatabaseType,
		arg.Status,
		arg.ExecutionTimeMs,
		arg.ExpectedOutput,
		arg.ActualOutput,
		arg.ErrorMessage,
		arg.IsCorrect,
		arg.Score,
		arg.AttemptNumber,
	)
	var i ExamSubmission
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.ExamProblemID,
		&i.UserID,
		&i.Code,
		&i.DatabaseType,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.ExpectedOutput,
		&i.ActualOutput,
		&i.ErrorMessage,
		&i.IsCorrect,
		&i.Score,
		&i.AttemptNumber,
		&i.SubmittedAt,
	)
	return i, err
}

const deleteExam = `-- name: DeleteExam :exec
DELETE FROM exams WHERE id = $1
`

func (q *Queries) DeleteExam(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteExam, id)
	return err
}

const getExamByID = `-- name: GetExamByID :one
SELECT e.id, e.title, e.description, e.created_by, e.start_time, e.end_time, e.duration_minutes, e.allowed_databases, e.allow_ai_assistance, e.shuffle_problems, e.show_result_immediately, e.max_attempts, e.is_public, e.status, e.created_at, e.updated_at, u.full_name as creator_name
FROM exams e
JOIN users u ON u.id = e.created_by
WHERE e.id = $1
`

type GetExamByIDRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
	CreatedAt             pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt             pgtype.Timestamptz `json:"updatedAt"`
	CreatorName           string             `json:"creatorName"`
}

func (q *Queries) GetExamByID(ctx context.Context, id int64) (GetExamByIDRow, error) {
	row := q.db.QueryRow(ctx, getExamByID, id)
	var i GetExamByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedBy,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.AllowedDatabases,
		&i.AllowAiAssistance,
		&i.ShuffleProblems,
		&i.ShowResultImmediately,
		&i.MaxAttempts,
		&i.IsPublic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatorName,
	)
	return i, err
}

const getExamResults = `-- name: GetExamResults :many
SELECT 
    u.id as user_id, u.full_name, u.student_id,
    ep.total_score, ep.started_at, ep.submitted_at, ep.status
FROM exam_participants ep
JOIN users u ON u.id = ep.user_id
WHERE ep.exam_id = $1
ORDER BY ep.total_score DESC
`

type GetExamResultsRow struct {
	UserID      int64              `json:"userId"`
	FullName    string             `json:"fullName"`
	StudentID   *string            `json:"studentId"`
	TotalScore  pgtype.Numeric     `json:"totalScore"`
	StartedAt   pgtype.Timestamptz `json:"startedAt"`
	SubmittedAt pgtype.Timestamptz `json:"submittedAt"`
	Status      *string            `json:"status"`
}

func (q *Queries) GetExamResults(ctx context.Context, examID int64) ([]GetExamResultsRow, error) {
	rows, err := q.db.Query(ctx, getExamResults, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExamResultsRow{}
	for rows.Next() {
		var i GetExamResultsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FullName,
			&i.StudentID,
			&i.TotalScore,
			&i.StartedAt,
			&i.SubmittedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamSubmission = `-- name: GetExamSubmission :one
SELECT id, exam_id, exam_problem_id, user_id, code, database_type, status, execution_time_ms, expected_output, actual_output, error_message, is_correct, score, attempt_number, submitted_at FROM exam_submissions
WHERE exam_id = $1 AND exam_problem_id = $2 AND user_id = $3
ORDER BY submitted_at DESC
LIMIT 1
`

type GetExamSubmissionParams struct {
	ExamID        int64 `json:"examId"`
	ExamProblemID int64 `json:"examProblemId"`
	UserID        int64 `json:"userId"`
}

func (q *Queries) GetExamSubmission(ctx context.Context, arg GetExamSubmissionParams) (ExamSubmission, error) {
	row := q.db.QueryRow(ctx, getExamSubmission, arg.ExamID, arg.ExamProblemID, arg.UserID)
	var i ExamSubmission
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.ExamProblemID,
		&i.UserID,
		&i.Code,
		&i.DatabaseType,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.ExpectedOutput,
		&i.ActualOutput,
		&i.ErrorMessage,
		&i.IsCorrect,
		&i.Score,
		&i.AttemptNumber,
		&i.SubmittedAt,
	)
	return i, err
}

const getParticipant = `-- name: GetParticipant :one
SELECT ep.id, ep.exam_id, ep.user_id, ep.started_at, ep.submitted_at, ep.total_score, ep.status, ep.created_at, u.full_name, u.email, u.student_id
FROM exam_participants ep
JOIN users u ON u.id = ep.user_id
WHERE ep.exam_id = $1 AND ep.user_id = $2
`

type GetParticipantParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

type GetParticipantRow struct {
	ID          int64              `json:"id"`
	ExamID      int64              `json:"examId"`
	UserID      int64              `json:"userId"`
	StartedAt   pgtype.Timestamptz `json:"startedAt"`
	SubmittedAt pgtype.Timestamptz `json:"submittedAt"`
	TotalScore  pgtype.Numeric     `json:"totalScore"`
	Status      *string            `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	FullName    string             `json:"fullName"`
	Email       string             `json:"email"`
	StudentID   *string            `json:"studentId"`
}

func (q *Queries) GetParticipant(ctx context.Context, arg GetParticipantParams) (GetParticipantRow, error) {
	row := q.db.QueryRow(ctx, getParticipant, arg.ExamID, arg.UserID)
	var i GetParticipantRow
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.UserID,
		&i.StartedAt,
		&i.SubmittedAt,
		&i.TotalScore,
		&i.Status,
		&i.CreatedAt,
		&i.FullName,
		&i.Email,
		&i.StudentID,
	)
	return i, err
}

const listExamParticipants = `-- name: ListExamParticipants :many
SELECT ep.id, ep.exam_id, ep.user_id, ep.started_at, ep.submitted_at, ep.total_score, ep.status, ep.created_at, u.full_name, u.email, u.student_id
FROM exam_participants ep
JOIN users u ON u.id = ep.user_id
WHERE ep.exam_id = $1
ORDER BY u.full_name ASC
`

type ListExamParticipantsRow struct {
	ID          int64              `json:"id"`
	ExamID      int64              `json:"examId"`
	UserID      int64              `json:"userId"`
	StartedAt   pgtype.Timestamptz `json:"startedAt"`
	SubmittedAt pgtype.Timestamptz `json:"submittedAt"`
	TotalScore  pgtype.Numeric     `json:"totalScore"`
	Status      *string            `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	FullName    string             `json:"fullName"`
	Email       string             `json:"email"`
	StudentID   *string            `json:"studentId"`
}

func (q *Queries) ListExamParticipants(ctx context.Context, examID int64) ([]ListExamParticipantsRow, error) {
	rows, err := q.db.Query(ctx, listExamParticipants, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExamParticipantsRow{}
	for rows.Next() {
		var i ListExamParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExamID,
			&i.UserID,
			&i.StartedAt,
			&i.SubmittedAt,
			&i.TotalScore,
			&i.Status,
			&i.CreatedAt,
			&i.FullName,
			&i.Email,
			&i.StudentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamProblems = `-- name: ListExamProblems :many
SELECT ep.id, ep.exam_id, ep.problem_id, ep.points, ep.sort_order, p.title, p.slug, p.difficulty, p.description
FROM exam_problems ep
JOIN problems p ON p.id = ep.problem_id
WHERE ep.exam_id = $1
ORDER BY ep.sort_order ASC
`

type ListExamProblemsRow struct {
	ID          int64  `json:"id"`
	ExamID      int64  `json:"examId"`
	ProblemID   int64  `json:"problemId"`
	Points      *int32 `json:"points"`
	SortOrder   *int32 `json:"sortOrder"`
	Title       string `json:"title"`
	Slug        string `json:"slug"`
	Difficulty  string `json:"difficulty"`
	Description string `json:"description"`
}

func (q *Queries) ListExamProblems(ctx context.Context, examID int64) ([]ListExamProblemsRow, error) {
	rows, err := q.db.Query(ctx, listExamProblems, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExamProblemsRow{}
	for rows.Next() {
		var i ListExamProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExamID,
			&i.ProblemID,
			&i.Points,
			&i.SortOrder,
			&i.Title,
			&i.Slug,
			&i.Difficulty,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExams = `-- name: ListExams :many
SELECT e.id, e.title, e.description, e.created_by, e.start_time, e.end_time, e.duration_minutes, e.allowed_databases, e.allow_ai_assistance, e.shuffle_problems, e.show_result_immediately, e.max_attempts, e.is_public, e.status, e.created_at, e.updated_at, u.full_name as creator_name,
    (SELECT COUNT(*) FROM exam_problems WHERE exam_id = e.id) as problem_count,
    (SELECT COUNT(*) FROM exam_participants WHERE exam_id = e.id) as participant_count
FROM exams e
JOIN users u ON u.id = e.created_by
ORDER BY e.created_at DESC
LIMIT $1 OFFSET $2
`

type ListExamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListExamsRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
	CreatedAt             pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt             pgtype.Timestamptz `json:"updatedAt"`
	CreatorName           string             `json:"creatorName"`
	ProblemCount          int64              `json:"problemCount"`
	ParticipantCount      int64              `json:"participantCount"`
}

func (q *Queries) ListExams(ctx context.Context, arg ListExamsParams) ([]ListExamsRow, error) {
	rows, err := q.db.Query(ctx, listExams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExamsRow{}
	for rows.Next() {
		var i ListExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedBy,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.AllowedDatabases,
			&i.AllowAiAssistance,
			&i.ShuffleProblems,
			&i.ShowResultImmediately,
			&i.MaxAttempts,
			&i.IsPublic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorName,
			&i.ProblemCount,
			&i.ParticipantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamsByLecturer = `-- name: ListExamsByLecturer :many
SELECT e.id, e.title, e.description, e.created_by, e.start_time, e.end_time, e.duration_minutes, e.allowed_databases, e.allow_ai_assistance, e.shuffle_problems, e.show_result_immediately, e.max_attempts, e.is_public, e.status, e.created_at, e.updated_at, 
    (SELECT COUNT(*) FROM exam_problems WHERE exam_id = e.id) as problem_count,
    (SELECT COUNT(*) FROM exam_participants WHERE exam_id = e.id) as participant_count
FROM exams e
WHERE e.created_by = $1
ORDER BY e.created_at DESC
LIMIT $2 OFFSET $3
`

type ListExamsByLecturerParams struct {
	CreatedBy int64 `json:"createdBy"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListExamsByLecturerRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
	CreatedAt             pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt             pgtype.Timestamptz `json:"updatedAt"`
	ProblemCount          int64              `json:"problemCount"`
	ParticipantCount      int64              `json:"participantCount"`
}

func (q *Queries) ListExamsByLecturer(ctx context.Context, arg ListExamsByLecturerParams) ([]ListExamsByLecturerRow, error) {
	rows, err := q.db.Query(ctx, listExamsByLecturer, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExamsByLecturerRow{}
	for rows.Next() {
		var i ListExamsByLecturerRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedBy,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.AllowedDatabases,
			&i.AllowAiAssistance,
			&i.ShuffleProblems,
			&i.ShowResultImmediately,
			&i.MaxAttempts,
			&i.IsPublic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProblemCount,
			&i.ParticipantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicExams = `-- name: ListPublicExams :many
SELECT e.id, e.title, e.description, e.created_by, e.start_time, e.end_time, e.duration_minutes, e.allowed_databases, e.allow_ai_assistance, e.shuffle_problems, e.show_result_immediately, e.max_attempts, e.is_public, e.status, e.created_at, e.updated_at, u.full_name as creator_name,
    (SELECT COUNT(*) FROM exam_problems WHERE exam_id = e.id) as problem_count
FROM exams e
JOIN users u ON u.id = e.created_by
WHERE e.is_public = TRUE AND e.status = 'published'
ORDER BY e.start_time DESC
LIMIT $1 OFFSET $2
`

type ListPublicExamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublicExamsRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
	CreatedAt             pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt             pgtype.Timestamptz `json:"updatedAt"`
	CreatorName           string             `json:"creatorName"`
	ProblemCount          int64              `json:"problemCount"`
}

func (q *Queries) ListPublicExams(ctx context.Context, arg ListPublicExamsParams) ([]ListPublicExamsRow, error) {
	rows, err := q.db.Query(ctx, listPublicExams, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicExamsRow{}
	for rows.Next() {
		var i ListPublicExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedBy,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.AllowedDatabases,
			&i.AllowAiAssistance,
			&i.ShuffleProblems,
			&i.ShowResultImmediately,
			&i.MaxAttempts,
			&i.IsPublic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatorName,
			&i.ProblemCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserExamSubmissions = `-- name: ListUserExamSubmissions :many
SELECT es.id, es.exam_id, es.exam_problem_id, es.user_id, es.code, es.database_type, es.status, es.execution_time_ms, es.expected_output, es.actual_output, es.error_message, es.is_correct, es.score, es.attempt_number, es.submitted_at, ep.points as max_points, p.title as problem_title
FROM exam_submissions es
JOIN exam_problems ep ON ep.id = es.exam_problem_id
JOIN problems p ON p.id = ep.problem_id
WHERE es.exam_id = $1 AND es.user_id = $2
ORDER BY es.submitted_at DESC
`

type ListUserExamSubmissionsParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

type ListUserExamSubmissionsRow struct {
	ID              int64              `json:"id"`
	ExamID          int64              `json:"examId"`
	ExamProblemID   int64              `json:"examProblemId"`
	UserID          int64              `json:"userId"`
	Code            string             `json:"code"`
	DatabaseType    string             `json:"databaseType"`
	Status          string             `json:"status"`
	ExecutionTimeMs *int32             `json:"executionTimeMs"`
	ExpectedOutput  []byte             `json:"expectedOutput"`
	ActualOutput    []byte             `json:"actualOutput"`
	ErrorMessage    *string            `json:"errorMessage"`
	IsCorrect       *bool              `json:"isCorrect"`
	Score           pgtype.Numeric     `json:"score"`
	AttemptNumber   *int32             `json:"attemptNumber"`
	SubmittedAt     pgtype.Timestamptz `json:"submittedAt"`
	MaxPoints       *int32             `json:"maxPoints"`
	ProblemTitle    string             `json:"problemTitle"`
}

func (q *Queries) ListUserExamSubmissions(ctx context.Context, arg ListUserExamSubmissionsParams) ([]ListUserExamSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, listUserExamSubmissions, arg.ExamID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserExamSubmissionsRow{}
	for rows.Next() {
		var i ListUserExamSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ExamID,
			&i.ExamProblemID,
			&i.UserID,
			&i.Code,
			&i.DatabaseType,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.ExpectedOutput,
			&i.ActualOutput,
			&i.ErrorMessage,
			&i.IsCorrect,
			&i.Score,
			&i.AttemptNumber,
			&i.SubmittedAt,
			&i.MaxPoints,
			&i.ProblemTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserExams = `-- name: ListUserExams :many
SELECT e.id, e.title, e.description, e.created_by, e.start_time, e.end_time, e.duration_minutes, e.allowed_databases, e.allow_ai_assistance, e.shuffle_problems, e.show_result_immediately, e.max_attempts, e.is_public, e.status, e.created_at, e.updated_at, ep.status as participation_status, ep.total_score, ep.started_at, ep.submitted_at
FROM exam_participants ep
JOIN exams e ON e.id = ep.exam_id
WHERE ep.user_id = $1
ORDER BY e.start_time DESC
`

type ListUserExamsRow struct {
	ID                    int64              `json:"id"`
	Title                 string             `json:"title"`
	Description           *string            `json:"description"`
	CreatedBy             int64              `json:"createdBy"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       int32              `json:"durationMinutes"`
	AllowedDatabases      []string           `json:"allowedDatabases"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
	Status                *string            `json:"status"`
	CreatedAt             pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt             pgtype.Timestamptz `json:"updatedAt"`
	ParticipationStatus   *string            `json:"participationStatus"`
	TotalScore            pgtype.Numeric     `json:"totalScore"`
	StartedAt             pgtype.Timestamptz `json:"startedAt"`
	SubmittedAt           pgtype.Timestamptz `json:"submittedAt"`
}

func (q *Queries) ListUserExams(ctx context.Context, userID int64) ([]ListUserExamsRow, error) {
	rows, err := q.db.Query(ctx, listUserExams, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserExamsRow{}
	for rows.Next() {
		var i ListUserExamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedBy,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.AllowedDatabases,
			&i.AllowAiAssistance,
			&i.ShuffleProblems,
			&i.ShowResultImmediately,
			&i.MaxAttempts,
			&i.IsPublic,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParticipationStatus,
			&i.TotalScore,
			&i.StartedAt,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeParticipant = `-- name: RemoveParticipant :exec
DELETE FROM exam_participants WHERE exam_id = $1 AND user_id = $2
`

type RemoveParticipantParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

func (q *Queries) RemoveParticipant(ctx context.Context, arg RemoveParticipantParams) error {
	_, err := q.db.Exec(ctx, removeParticipant, arg.ExamID, arg.UserID)
	return err
}

const removeProblemFromExam = `-- name: RemoveProblemFromExam :exec
DELETE FROM exam_problems WHERE exam_id = $1 AND problem_id = $2
`

type RemoveProblemFromExamParams struct {
	ExamID    int64 `json:"examId"`
	ProblemID int64 `json:"problemId"`
}

func (q *Queries) RemoveProblemFromExam(ctx context.Context, arg RemoveProblemFromExamParams) error {
	_, err := q.db.Exec(ctx, removeProblemFromExam, arg.ExamID, arg.ProblemID)
	return err
}

const startExam = `-- name: StartExam :one
UPDATE exam_participants SET 
    status = 'in_progress',
    started_at = NOW()
WHERE exam_id = $1 AND user_id = $2
RETURNING id, exam_id, user_id, started_at, submitted_at, total_score, status, created_at
`

type StartExamParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

func (q *Queries) StartExam(ctx context.Context, arg StartExamParams) (ExamParticipant, error) {
	row := q.db.QueryRow(ctx, startExam, arg.ExamID, arg.UserID)
	var i ExamParticipant
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.UserID,
		&i.StartedAt,
		&i.SubmittedAt,
		&i.TotalScore,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const submitExam = `-- name: SubmitExam :one
UPDATE exam_participants SET 
    status = 'submitted',
    submitted_at = NOW()
WHERE exam_id = $1 AND user_id = $2
RETURNING id, exam_id, user_id, started_at, submitted_at, total_score, status, created_at
`

type SubmitExamParams struct {
	ExamID int64 `json:"examId"`
	UserID int64 `json:"userId"`
}

func (q *Queries) SubmitExam(ctx context.Context, arg SubmitExamParams) (ExamParticipant, error) {
	row := q.db.QueryRow(ctx, submitExam, arg.ExamID, arg.UserID)
	var i ExamParticipant
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.UserID,
		&i.StartedAt,
		&i.SubmittedAt,
		&i.TotalScore,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateExam = `-- name: UpdateExam :one
UPDATE exams SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    start_time = COALESCE($4, start_time),
    end_time = COALESCE($5, end_time),
    duration_minutes = COALESCE($6, duration_minutes),
    allow_ai_assistance = COALESCE($7, allow_ai_assistance),
    shuffle_problems = COALESCE($8, shuffle_problems),
    show_result_immediately = COALESCE($9, show_result_immediately),
    max_attempts = COALESCE($10, max_attempts),
    is_public = COALESCE($11, is_public),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, created_by, start_time, end_time, duration_minutes, allowed_databases, allow_ai_assistance, shuffle_problems, show_result_immediately, max_attempts, is_public, status, created_at, updated_at
`

type UpdateExamParams struct {
	ID                    int64              `json:"id"`
	Title                 *string            `json:"title"`
	Description           *string            `json:"description"`
	StartTime             pgtype.Timestamptz `json:"startTime"`
	EndTime               pgtype.Timestamptz `json:"endTime"`
	DurationMinutes       *int32             `json:"durationMinutes"`
	AllowAiAssistance     *bool              `json:"allowAiAssistance"`
	ShuffleProblems       *bool              `json:"shuffleProblems"`
	ShowResultImmediately *bool              `json:"showResultImmediately"`
	MaxAttempts           *int32             `json:"maxAttempts"`
	IsPublic              *bool              `json:"isPublic"`
}

func (q *Queries) UpdateExam(ctx context.Context, arg UpdateExamParams) (Exam, error) {
	row := q.db.QueryRow(ctx, updateExam,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.DurationMinutes,
		arg.AllowAiAssistance,
		arg.ShuffleProblems,
		arg.ShowResultImmediately,
		arg.MaxAttempts,
		arg.IsPublic,
	)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedBy,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.AllowedDatabases,
		&i.AllowAiAssistance,
		&i.ShuffleProblems,
		&i.ShowResultImmediately,
		&i.MaxAttempts,
		&i.IsPublic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateExamProblemPoints = `-- name: UpdateExamProblemPoints :one
UPDATE exam_problems SET points = $3
WHERE exam_id = $1 AND problem_id = $2
RETURNING id, exam_id, problem_id, points, sort_order
`

type UpdateExamProblemPointsParams struct {
	ExamID    int64  `json:"examId"`
	ProblemID int64  `json:"problemId"`
	Points    *int32 `json:"points"`
}

func (q *Queries) UpdateExamProblemPoints(ctx context.Context, arg UpdateExamProblemPointsParams) (ExamProblem, error) {
	row := q.db.QueryRow(ctx, updateExamProblemPoints, arg.ExamID, arg.ProblemID, arg.Points)
	var i ExamProblem
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.ProblemID,
		&i.Points,
		&i.SortOrder,
	)
	return i, err
}

const updateExamStatus = `-- name: UpdateExamStatus :one
UPDATE exams SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, created_by, start_time, end_time, duration_minutes, allowed_databases, allow_ai_assistance, shuffle_problems, show_result_immediately, max_attempts, is_public, status, created_at, updated_at
`

type UpdateExamStatusParams struct {
	ID     int64   `json:"id"`
	Status *string `json:"status"`
}

func (q *Queries) UpdateExamStatus(ctx context.Context, arg UpdateExamStatusParams) (Exam, error) {
	row := q.db.QueryRow(ctx, updateExamStatus, arg.ID, arg.Status)
	var i Exam
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedBy,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.AllowedDatabases,
		&i.AllowAiAssistance,
		&i.ShuffleProblems,
		&i.ShowResultImmediately,
		&i.MaxAttempts,
		&i.IsPublic,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateParticipantScore = `-- name: UpdateParticipantScore :one
UPDATE exam_participants SET 
    total_score = $3,
    status = 'graded'
WHERE exam_id = $1 AND user_id = $2
RETURNING id, exam_id, user_id, started_at, submitted_at, total_score, status, created_at
`

type UpdateParticipantScoreParams struct {
	ExamID     int64          `json:"examId"`
	UserID     int64          `json:"userId"`
	TotalScore pgtype.Numeric `json:"totalScore"`
}

func (q *Queries) UpdateParticipantScore(ctx context.Context, arg UpdateParticipantScoreParams) (ExamParticipant, error) {
	row := q.db.QueryRow(ctx, updateParticipantScore, arg.ExamID, arg.UserID, arg.TotalScore)
	var i ExamParticipant
	err := row.Scan(
		&i.ID,
		&i.ExamID,
		&i.UserID,
		&i.StartedAt,
		&i.SubmittedAt,
		&i.TotalScore,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
