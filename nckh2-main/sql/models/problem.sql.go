// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: problem.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProblems = `-- name: CountProblems :one
SELECT COUNT(*) FROM problems WHERE is_public = TRUE AND is_active = TRUE
`

func (q *Queries) CountProblems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProblems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProblemsByDifficulty = `-- name: CountProblemsByDifficulty :many
SELECT difficulty, COUNT(*) as count
FROM problems
WHERE is_public = TRUE AND is_active = TRUE
GROUP BY difficulty
`

type CountProblemsByDifficultyRow struct {
	Difficulty string `json:"difficulty"`
	Count      int64  `json:"count"`
}

func (q *Queries) CountProblemsByDifficulty(ctx context.Context) ([]CountProblemsByDifficultyRow, error) {
	rows, err := q.db.Query(ctx, countProblemsByDifficulty)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountProblemsByDifficultyRow{}
	for rows.Next() {
		var i CountProblemsByDifficultyRow
		if err := rows.Scan(&i.Difficulty, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createProblem = `-- name: CreateProblem :one
INSERT INTO problems (
    title, slug, description, difficulty, topic_id, created_by,
    init_script, solution_query, supported_databases, order_matters,
    hints, sample_output, is_public
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, slug, description, difficulty, topic_id, created_by, init_script, solution_query, supported_databases, order_matters, hints, sample_output, is_public, is_active, created_at, updated_at
`

type CreateProblemParams struct {
	Title              string   `json:"title"`
	Slug               string   `json:"slug"`
	Description        string   `json:"description"`
	Difficulty         string   `json:"difficulty"`
	TopicID            *int32   `json:"topicId"`
	CreatedBy          *int64   `json:"createdBy"`
	InitScript         string   `json:"initScript"`
	SolutionQuery      string   `json:"solutionQuery"`
	SupportedDatabases []string `json:"supportedDatabases"`
	OrderMatters       *bool    `json:"orderMatters"`
	Hints              []byte   `json:"hints"`
	SampleOutput       []byte   `json:"sampleOutput"`
	IsPublic           *bool    `json:"isPublic"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, createProblem,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Difficulty,
		arg.TopicID,
		arg.CreatedBy,
		arg.InitScript,
		arg.SolutionQuery,
		arg.SupportedDatabases,
		arg.OrderMatters,
		arg.Hints,
		arg.SampleOutput,
		arg.IsPublic,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Difficulty,
		&i.TopicID,
		&i.CreatedBy,
		&i.InitScript,
		&i.SolutionQuery,
		&i.SupportedDatabases,
		&i.OrderMatters,
		&i.Hints,
		&i.SampleOutput,
		&i.IsPublic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProblem = `-- name: DeleteProblem :exec
UPDATE problems SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteProblem(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProblem, id)
	return err
}

const getProblemByID = `-- name: GetProblemByID :one
SELECT id, title, slug, description, difficulty, topic_id, created_by, init_script, solution_query, supported_databases, order_matters, hints, sample_output, is_public, is_active, created_at, updated_at FROM problems WHERE id = $1
`

func (q *Queries) GetProblemByID(ctx context.Context, id int64) (Problem, error) {
	row := q.db.QueryRow(ctx, getProblemByID, id)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Difficulty,
		&i.TopicID,
		&i.CreatedBy,
		&i.InitScript,
		&i.SolutionQuery,
		&i.SupportedDatabases,
		&i.OrderMatters,
		&i.Hints,
		&i.SampleOutput,
		&i.IsPublic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProblemBySlug = `-- name: GetProblemBySlug :one
SELECT id, title, slug, description, difficulty, topic_id, created_by, init_script, solution_query, supported_databases, order_matters, hints, sample_output, is_public, is_active, created_at, updated_at FROM problems WHERE slug = $1 AND is_active = TRUE
`

func (q *Queries) GetProblemBySlug(ctx context.Context, slug string) (Problem, error) {
	row := q.db.QueryRow(ctx, getProblemBySlug, slug)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Difficulty,
		&i.TopicID,
		&i.CreatedBy,
		&i.InitScript,
		&i.SolutionQuery,
		&i.SupportedDatabases,
		&i.OrderMatters,
		&i.Hints,
		&i.SampleOutput,
		&i.IsPublic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProblemWithUserProgress = `-- name: GetProblemWithUserProgress :one
SELECT 
    p.id, p.title, p.slug, p.description, p.difficulty, p.topic_id, p.created_by, p.init_script, p.solution_query, p.supported_databases, p.order_matters, p.hints, p.sample_output, p.is_public, p.is_active, p.created_at, p.updated_at,
    t.name as topic_name,
    t.slug as topic_slug,
    up.is_solved,
    up.attempts,
    up.best_time_ms
FROM problems p
LEFT JOIN topics t ON t.id = p.topic_id
LEFT JOIN user_progress up ON up.problem_id = p.id AND up.user_id = $2
WHERE p.slug = $1 AND p.is_active = TRUE
`

type GetProblemWithUserProgressParams struct {
	Slug   string `json:"slug"`
	UserID int64  `json:"userId"`
}

type GetProblemWithUserProgressRow struct {
	ID                 int64              `json:"id"`
	Title              string             `json:"title"`
	Slug               string             `json:"slug"`
	Description        string             `json:"description"`
	Difficulty         string             `json:"difficulty"`
	TopicID            *int32             `json:"topicId"`
	CreatedBy          *int64             `json:"createdBy"`
	InitScript         string             `json:"initScript"`
	SolutionQuery      string             `json:"solutionQuery"`
	SupportedDatabases []string           `json:"supportedDatabases"`
	OrderMatters       *bool              `json:"orderMatters"`
	Hints              []byte             `json:"hints"`
	SampleOutput       []byte             `json:"sampleOutput"`
	IsPublic           *bool              `json:"isPublic"`
	IsActive           *bool              `json:"isActive"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	TopicName          *string            `json:"topicName"`
	TopicSlug          *string            `json:"topicSlug"`
	IsSolved           *bool              `json:"isSolved"`
	Attempts           *int32             `json:"attempts"`
	BestTimeMs         *int32             `json:"bestTimeMs"`
}

func (q *Queries) GetProblemWithUserProgress(ctx context.Context, arg GetProblemWithUserProgressParams) (GetProblemWithUserProgressRow, error) {
	row := q.db.QueryRow(ctx, getProblemWithUserProgress, arg.Slug, arg.UserID)
	var i GetProblemWithUserProgressRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Difficulty,
		&i.TopicID,
		&i.CreatedBy,
		&i.InitScript,
		&i.SolutionQuery,
		&i.SupportedDatabases,
		&i.OrderMatters,
		&i.Hints,
		&i.SampleOutput,
		&i.IsPublic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TopicName,
		&i.TopicSlug,
		&i.IsSolved,
		&i.Attempts,
		&i.BestTimeMs,
	)
	return i, err
}

const listProblems = `-- name: ListProblems :many
SELECT p.id, p.title, p.slug, p.description, p.difficulty, p.topic_id, p.created_by, p.init_script, p.solution_query, p.supported_databases, p.order_matters, p.hints, p.sample_output, p.is_public, p.is_active, p.created_at, p.updated_at, t.name as topic_name, t.slug as topic_slug
FROM problems p
LEFT JOIN topics t ON t.id = p.topic_id
WHERE p.is_public = TRUE AND p.is_active = TRUE
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListProblemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProblemsRow struct {
	ID                 int64              `json:"id"`
	Title              string             `json:"title"`
	Slug               string             `json:"slug"`
	Description        string             `json:"description"`
	Difficulty         string             `json:"difficulty"`
	TopicID            *int32             `json:"topicId"`
	CreatedBy          *int64             `json:"createdBy"`
	InitScript         string             `json:"initScript"`
	SolutionQuery      string             `json:"solutionQuery"`
	SupportedDatabases []string           `json:"supportedDatabases"`
	OrderMatters       *bool              `json:"orderMatters"`
	Hints              []byte             `json:"hints"`
	SampleOutput       []byte             `json:"sampleOutput"`
	IsPublic           *bool              `json:"isPublic"`
	IsActive           *bool              `json:"isActive"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	TopicName          *string            `json:"topicName"`
	TopicSlug          *string            `json:"topicSlug"`
}

func (q *Queries) ListProblems(ctx context.Context, arg ListProblemsParams) ([]ListProblemsRow, error) {
	rows, err := q.db.Query(ctx, listProblems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProblemsRow{}
	for rows.Next() {
		var i ListProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Difficulty,
			&i.TopicID,
			&i.CreatedBy,
			&i.InitScript,
			&i.SolutionQuery,
			&i.SupportedDatabases,
			&i.OrderMatters,
			&i.Hints,
			&i.SampleOutput,
			&i.IsPublic,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicName,
			&i.TopicSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProblemsByDifficulty = `-- name: ListProblemsByDifficulty :many
SELECT p.id, p.title, p.slug, p.description, p.difficulty, p.topic_id, p.created_by, p.init_script, p.solution_query, p.supported_databases, p.order_matters, p.hints, p.sample_output, p.is_public, p.is_active, p.created_at, p.updated_at, t.name as topic_name, t.slug as topic_slug
FROM problems p
LEFT JOIN topics t ON t.id = p.topic_id
WHERE p.difficulty = $1 AND p.is_public = TRUE AND p.is_active = TRUE
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProblemsByDifficultyParams struct {
	Difficulty string `json:"difficulty"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type ListProblemsByDifficultyRow struct {
	ID                 int64              `json:"id"`
	Title              string             `json:"title"`
	Slug               string             `json:"slug"`
	Description        string             `json:"description"`
	Difficulty         string             `json:"difficulty"`
	TopicID            *int32             `json:"topicId"`
	CreatedBy          *int64             `json:"createdBy"`
	InitScript         string             `json:"initScript"`
	SolutionQuery      string             `json:"solutionQuery"`
	SupportedDatabases []string           `json:"supportedDatabases"`
	OrderMatters       *bool              `json:"orderMatters"`
	Hints              []byte             `json:"hints"`
	SampleOutput       []byte             `json:"sampleOutput"`
	IsPublic           *bool              `json:"isPublic"`
	IsActive           *bool              `json:"isActive"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	TopicName          *string            `json:"topicName"`
	TopicSlug          *string            `json:"topicSlug"`
}

func (q *Queries) ListProblemsByDifficulty(ctx context.Context, arg ListProblemsByDifficultyParams) ([]ListProblemsByDifficultyRow, error) {
	rows, err := q.db.Query(ctx, listProblemsByDifficulty, arg.Difficulty, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProblemsByDifficultyRow{}
	for rows.Next() {
		var i ListProblemsByDifficultyRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Difficulty,
			&i.TopicID,
			&i.CreatedBy,
			&i.InitScript,
			&i.SolutionQuery,
			&i.SupportedDatabases,
			&i.OrderMatters,
			&i.Hints,
			&i.SampleOutput,
			&i.IsPublic,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicName,
			&i.TopicSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProblemsByTopic = `-- name: ListProblemsByTopic :many
SELECT p.id, p.title, p.slug, p.description, p.difficulty, p.topic_id, p.created_by, p.init_script, p.solution_query, p.supported_databases, p.order_matters, p.hints, p.sample_output, p.is_public, p.is_active, p.created_at, p.updated_at, t.name as topic_name, t.slug as topic_slug
FROM problems p
LEFT JOIN topics t ON t.id = p.topic_id
WHERE p.topic_id = $1 AND p.is_public = TRUE AND p.is_active = TRUE
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProblemsByTopicParams struct {
	TopicID *int32 `json:"topicId"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListProblemsByTopicRow struct {
	ID                 int64              `json:"id"`
	Title              string             `json:"title"`
	Slug               string             `json:"slug"`
	Description        string             `json:"description"`
	Difficulty         string             `json:"difficulty"`
	TopicID            *int32             `json:"topicId"`
	CreatedBy          *int64             `json:"createdBy"`
	InitScript         string             `json:"initScript"`
	SolutionQuery      string             `json:"solutionQuery"`
	SupportedDatabases []string           `json:"supportedDatabases"`
	OrderMatters       *bool              `json:"orderMatters"`
	Hints              []byte             `json:"hints"`
	SampleOutput       []byte             `json:"sampleOutput"`
	IsPublic           *bool              `json:"isPublic"`
	IsActive           *bool              `json:"isActive"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	TopicName          *string            `json:"topicName"`
	TopicSlug          *string            `json:"topicSlug"`
}

func (q *Queries) ListProblemsByTopic(ctx context.Context, arg ListProblemsByTopicParams) ([]ListProblemsByTopicRow, error) {
	rows, err := q.db.Query(ctx, listProblemsByTopic, arg.TopicID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProblemsByTopicRow{}
	for rows.Next() {
		var i ListProblemsByTopicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.Difficulty,
			&i.TopicID,
			&i.CreatedBy,
			&i.InitScript,
			&i.SolutionQuery,
			&i.SupportedDatabases,
			&i.OrderMatters,
			&i.Hints,
			&i.SampleOutput,
			&i.IsPublic,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicName,
			&i.TopicSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProblem = `-- name: UpdateProblem :one
UPDATE problems SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    difficulty = COALESCE($4, difficulty),
    topic_id = COALESCE($5, topic_id),
    init_script = COALESCE($6, init_script),
    solution_query = COALESCE($7, solution_query),
    hints = COALESCE($8, hints),
    sample_output = COALESCE($9, sample_output),
    order_matters = COALESCE($10, order_matters),
    is_public = COALESCE($11, is_public),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, description, difficulty, topic_id, created_by, init_script, solution_query, supported_databases, order_matters, hints, sample_output, is_public, is_active, created_at, updated_at
`

type UpdateProblemParams struct {
	ID            int64   `json:"id"`
	Title         *string `json:"title"`
	Description   *string `json:"description"`
	Difficulty    *string `json:"difficulty"`
	TopicID       *int32  `json:"topicId"`
	InitScript    *string `json:"initScript"`
	SolutionQuery *string `json:"solutionQuery"`
	Hints         []byte  `json:"hints"`
	SampleOutput  []byte  `json:"sampleOutput"`
	OrderMatters  *bool   `json:"orderMatters"`
	IsPublic      *bool   `json:"isPublic"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, updateProblem,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Difficulty,
		arg.TopicID,
		arg.InitScript,
		arg.SolutionQuery,
		arg.Hints,
		arg.SampleOutput,
		arg.OrderMatters,
		arg.IsPublic,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.Difficulty,
		&i.TopicID,
		&i.CreatedBy,
		&i.InitScript,
		&i.SolutionQuery,
		&i.SupportedDatabases,
		&i.OrderMatters,
		&i.Hints,
		&i.SampleOutput,
		&i.IsPublic,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
