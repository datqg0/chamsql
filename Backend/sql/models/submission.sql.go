// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: submission.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCorrectSubmissions = `-- name: CountCorrectSubmissions :one
SELECT COUNT(*) FROM submissions WHERE user_id = $1 AND is_correct = TRUE
`

func (q *Queries) CountCorrectSubmissions(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countCorrectSubmissions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserSubmissions = `-- name: CountUserSubmissions :one
SELECT COUNT(*) FROM submissions WHERE user_id = $1
`

func (q *Queries) CountUserSubmissions(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSubmissions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (
    user_id, problem_id, code, database_type, status,
    execution_time_ms, expected_output, actual_output, error_message, is_correct
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, problem_id, code, database_type, status, execution_time_ms, expected_output, actual_output, error_message, is_correct, submitted_at
`

type CreateSubmissionParams struct {
	UserID          int64   `json:"userId"`
	ProblemID       int64   `json:"problemId"`
	Code            string  `json:"code"`
	DatabaseType    string  `json:"databaseType"`
	Status          string  `json:"status"`
	ExecutionTimeMs *int32  `json:"executionTimeMs"`
	ExpectedOutput  []byte  `json:"expectedOutput"`
	ActualOutput    []byte  `json:"actualOutput"`
	ErrorMessage    *string `json:"errorMessage"`
	IsCorrect       *bool   `json:"isCorrect"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.UserID,
		arg.ProblemID,
		arg.Code,
		arg.DatabaseType,
		arg.Status,
		arg.ExecutionTimeMs,
		arg.ExpectedOutput,
		arg.ActualOutput,
		arg.ErrorMessage,
		arg.IsCorrect,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Code,
		&i.DatabaseType,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.ExpectedOutput,
		&i.ActualOutput,
		&i.ErrorMessage,
		&i.IsCorrect,
		&i.SubmittedAt,
	)
	return i, err
}

const getLatestSubmission = `-- name: GetLatestSubmission :one
SELECT id, user_id, problem_id, code, database_type, status, execution_time_ms, expected_output, actual_output, error_message, is_correct, submitted_at FROM submissions
WHERE user_id = $1 AND problem_id = $2
ORDER BY submitted_at DESC
LIMIT 1
`

type GetLatestSubmissionParams struct {
	UserID    int64 `json:"userId"`
	ProblemID int64 `json:"problemId"`
}

func (q *Queries) GetLatestSubmission(ctx context.Context, arg GetLatestSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, getLatestSubmission, arg.UserID, arg.ProblemID)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Code,
		&i.DatabaseType,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.ExpectedOutput,
		&i.ActualOutput,
		&i.ErrorMessage,
		&i.IsCorrect,
		&i.SubmittedAt,
	)
	return i, err
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT s.id, s.user_id, s.problem_id, s.code, s.database_type, s.status, s.execution_time_ms, s.expected_output, s.actual_output, s.error_message, s.is_correct, s.submitted_at, p.title as problem_title, p.slug as problem_slug
FROM submissions s
JOIN problems p ON p.id = s.problem_id
WHERE s.id = $1
`

type GetSubmissionByIDRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"userId"`
	ProblemID       int64              `json:"problemId"`
	Code            string             `json:"code"`
	DatabaseType    string             `json:"databaseType"`
	Status          string             `json:"status"`
	ExecutionTimeMs *int32             `json:"executionTimeMs"`
	ExpectedOutput  []byte             `json:"expectedOutput"`
	ActualOutput    []byte             `json:"actualOutput"`
	ErrorMessage    *string            `json:"errorMessage"`
	IsCorrect       *bool              `json:"isCorrect"`
	SubmittedAt     pgtype.Timestamptz `json:"submittedAt"`
	ProblemTitle    string             `json:"problemTitle"`
	ProblemSlug     string             `json:"problemSlug"`
}

func (q *Queries) GetSubmissionByID(ctx context.Context, id int64) (GetSubmissionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubmissionByID, id)
	var i GetSubmissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.Code,
		&i.DatabaseType,
		&i.Status,
		&i.ExecutionTimeMs,
		&i.ExpectedOutput,
		&i.ActualOutput,
		&i.ErrorMessage,
		&i.IsCorrect,
		&i.SubmittedAt,
		&i.ProblemTitle,
		&i.ProblemSlug,
	)
	return i, err
}

const listUserSubmissions = `-- name: ListUserSubmissions :many
SELECT s.id, s.user_id, s.problem_id, s.code, s.database_type, s.status, s.execution_time_ms, s.expected_output, s.actual_output, s.error_message, s.is_correct, s.submitted_at, p.title as problem_title, p.slug as problem_slug
FROM submissions s
JOIN problems p ON p.id = s.problem_id
WHERE s.user_id = $1
ORDER BY s.submitted_at DESC
LIMIT $2 OFFSET $3
`

type ListUserSubmissionsParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUserSubmissionsRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"userId"`
	ProblemID       int64              `json:"problemId"`
	Code            string             `json:"code"`
	DatabaseType    string             `json:"databaseType"`
	Status          string             `json:"status"`
	ExecutionTimeMs *int32             `json:"executionTimeMs"`
	ExpectedOutput  []byte             `json:"expectedOutput"`
	ActualOutput    []byte             `json:"actualOutput"`
	ErrorMessage    *string            `json:"errorMessage"`
	IsCorrect       *bool              `json:"isCorrect"`
	SubmittedAt     pgtype.Timestamptz `json:"submittedAt"`
	ProblemTitle    string             `json:"problemTitle"`
	ProblemSlug     string             `json:"problemSlug"`
}

func (q *Queries) ListUserSubmissions(ctx context.Context, arg ListUserSubmissionsParams) ([]ListUserSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, listUserSubmissions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSubmissionsRow{}
	for rows.Next() {
		var i ListUserSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Code,
			&i.DatabaseType,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.ExpectedOutput,
			&i.ActualOutput,
			&i.ErrorMessage,
			&i.IsCorrect,
			&i.SubmittedAt,
			&i.ProblemTitle,
			&i.ProblemSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSubmissionsForProblem = `-- name: ListUserSubmissionsForProblem :many
SELECT id, user_id, problem_id, code, database_type, status, execution_time_ms, expected_output, actual_output, error_message, is_correct, submitted_at FROM submissions
WHERE user_id = $1 AND problem_id = $2
ORDER BY submitted_at DESC
LIMIT $3
`

type ListUserSubmissionsForProblemParams struct {
	UserID    int64 `json:"userId"`
	ProblemID int64 `json:"problemId"`
	Limit     int32 `json:"limit"`
}

func (q *Queries) ListUserSubmissionsForProblem(ctx context.Context, arg ListUserSubmissionsForProblemParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listUserSubmissionsForProblem, arg.UserID, arg.ProblemID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Code,
			&i.DatabaseType,
			&i.Status,
			&i.ExecutionTimeMs,
			&i.ExpectedOutput,
			&i.ActualOutput,
			&i.ErrorMessage,
			&i.IsCorrect,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
