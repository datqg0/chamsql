// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: progress.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserProgress = `-- name: GetUserProgress :one
SELECT id, user_id, problem_id, is_solved, attempts, best_time_ms, first_attempted_at, last_attempted_at, solved_at FROM user_progress
WHERE user_id = $1 AND problem_id = $2
`

type GetUserProgressParams struct {
	UserID    int64 `json:"userId"`
	ProblemID int64 `json:"problemId"`
}

func (q *Queries) GetUserProgress(ctx context.Context, arg GetUserProgressParams) (UserProgress, error) {
	row := q.db.QueryRow(ctx, getUserProgress, arg.UserID, arg.ProblemID)
	var i UserProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.IsSolved,
		&i.Attempts,
		&i.BestTimeMs,
		&i.FirstAttemptedAt,
		&i.LastAttemptedAt,
		&i.SolvedAt,
	)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT 
    COUNT(*) as total_attempted,
    COUNT(*) FILTER (WHERE is_solved = TRUE) as total_solved,
    SUM(attempts) as total_submissions
FROM user_progress
WHERE user_id = $1
`

type GetUserStatsRow struct {
	TotalAttempted   int64 `json:"totalAttempted"`
	TotalSolved      int64 `json:"totalSolved"`
	TotalSubmissions int64 `json:"totalSubmissions"`
}

func (q *Queries) GetUserStats(ctx context.Context, userID int64) (GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserStats, userID)
	var i GetUserStatsRow
	err := row.Scan(&i.TotalAttempted, &i.TotalSolved, &i.TotalSubmissions)
	return i, err
}

const getUserStatsByDifficulty = `-- name: GetUserStatsByDifficulty :many
SELECT 
    p.difficulty,
    COUNT(*) FILTER (WHERE up.is_solved = TRUE) as solved,
    COUNT(DISTINCT p.id) as total
FROM problems p
LEFT JOIN user_progress up ON up.problem_id = p.id AND up.user_id = $1
WHERE p.is_public = TRUE AND p.is_active = TRUE
GROUP BY p.difficulty
`

type GetUserStatsByDifficultyRow struct {
	Difficulty string `json:"difficulty"`
	Solved     int64  `json:"solved"`
	Total      int64  `json:"total"`
}

func (q *Queries) GetUserStatsByDifficulty(ctx context.Context, userID int64) ([]GetUserStatsByDifficultyRow, error) {
	rows, err := q.db.Query(ctx, getUserStatsByDifficulty, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStatsByDifficultyRow{}
	for rows.Next() {
		var i GetUserStatsByDifficultyRow
		if err := rows.Scan(&i.Difficulty, &i.Solved, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentAttempts = `-- name: ListRecentAttempts :many
SELECT up.id, up.user_id, up.problem_id, up.is_solved, up.attempts, up.best_time_ms, up.first_attempted_at, up.last_attempted_at, up.solved_at, p.title, p.slug, p.difficulty
FROM user_progress up
JOIN problems p ON p.id = up.problem_id
WHERE up.user_id = $1
ORDER BY up.last_attempted_at DESC
LIMIT $2
`

type ListRecentAttemptsParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
}

type ListRecentAttemptsRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"userId"`
	ProblemID        int64              `json:"problemId"`
	IsSolved         *bool              `json:"isSolved"`
	Attempts         *int32             `json:"attempts"`
	BestTimeMs       *int32             `json:"bestTimeMs"`
	FirstAttemptedAt pgtype.Timestamptz `json:"firstAttemptedAt"`
	LastAttemptedAt  pgtype.Timestamptz `json:"lastAttemptedAt"`
	SolvedAt         pgtype.Timestamptz `json:"solvedAt"`
	Title            string             `json:"title"`
	Slug             string             `json:"slug"`
	Difficulty       string             `json:"difficulty"`
}

func (q *Queries) ListRecentAttempts(ctx context.Context, arg ListRecentAttemptsParams) ([]ListRecentAttemptsRow, error) {
	rows, err := q.db.Query(ctx, listRecentAttempts, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentAttemptsRow{}
	for rows.Next() {
		var i ListRecentAttemptsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.IsSolved,
			&i.Attempts,
			&i.BestTimeMs,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.SolvedAt,
			&i.Title,
			&i.Slug,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSolvedProblems = `-- name: ListSolvedProblems :many
SELECT up.id, up.user_id, up.problem_id, up.is_solved, up.attempts, up.best_time_ms, up.first_attempted_at, up.last_attempted_at, up.solved_at, p.title, p.slug, p.difficulty
FROM user_progress up
JOIN problems p ON p.id = up.problem_id
WHERE up.user_id = $1 AND up.is_solved = TRUE
ORDER BY up.solved_at DESC
LIMIT $2 OFFSET $3
`

type ListSolvedProblemsParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSolvedProblemsRow struct {
	ID               int64              `json:"id"`
	UserID           int64              `json:"userId"`
	ProblemID        int64              `json:"problemId"`
	IsSolved         *bool              `json:"isSolved"`
	Attempts         *int32             `json:"attempts"`
	BestTimeMs       *int32             `json:"bestTimeMs"`
	FirstAttemptedAt pgtype.Timestamptz `json:"firstAttemptedAt"`
	LastAttemptedAt  pgtype.Timestamptz `json:"lastAttemptedAt"`
	SolvedAt         pgtype.Timestamptz `json:"solvedAt"`
	Title            string             `json:"title"`
	Slug             string             `json:"slug"`
	Difficulty       string             `json:"difficulty"`
}

func (q *Queries) ListSolvedProblems(ctx context.Context, arg ListSolvedProblemsParams) ([]ListSolvedProblemsRow, error) {
	rows, err := q.db.Query(ctx, listSolvedProblems, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSolvedProblemsRow{}
	for rows.Next() {
		var i ListSolvedProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.IsSolved,
			&i.Attempts,
			&i.BestTimeMs,
			&i.FirstAttemptedAt,
			&i.LastAttemptedAt,
			&i.SolvedAt,
			&i.Title,
			&i.Slug,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markProblemSolved = `-- name: MarkProblemSolved :one
UPDATE user_progress SET 
    is_solved = TRUE,
    best_time_ms = CASE 
        WHEN best_time_ms IS NULL THEN $3
        WHEN $3 < best_time_ms THEN $3
        ELSE best_time_ms
    END,
    solved_at = COALESCE(solved_at, NOW())
WHERE user_id = $1 AND problem_id = $2
RETURNING id, user_id, problem_id, is_solved, attempts, best_time_ms, first_attempted_at, last_attempted_at, solved_at
`

type MarkProblemSolvedParams struct {
	UserID     int64  `json:"userId"`
	ProblemID  int64  `json:"problemId"`
	BestTimeMs *int32 `json:"bestTimeMs"`
}

func (q *Queries) MarkProblemSolved(ctx context.Context, arg MarkProblemSolvedParams) (UserProgress, error) {
	row := q.db.QueryRow(ctx, markProblemSolved, arg.UserID, arg.ProblemID, arg.BestTimeMs)
	var i UserProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.IsSolved,
		&i.Attempts,
		&i.BestTimeMs,
		&i.FirstAttemptedAt,
		&i.LastAttemptedAt,
		&i.SolvedAt,
	)
	return i, err
}

const upsertProgress = `-- name: UpsertProgress :one
INSERT INTO user_progress (user_id, problem_id, attempts, first_attempted_at, last_attempted_at)
VALUES ($1, $2, 1, NOW(), NOW())
ON CONFLICT (user_id, problem_id) 
DO UPDATE SET 
    attempts = user_progress.attempts + 1,
    last_attempted_at = NOW()
RETURNING id, user_id, problem_id, is_solved, attempts, best_time_ms, first_attempted_at, last_attempted_at, solved_at
`

type UpsertProgressParams struct {
	UserID    int64 `json:"userId"`
	ProblemID int64 `json:"problemId"`
}

func (q *Queries) UpsertProgress(ctx context.Context, arg UpsertProgressParams) (UserProgress, error) {
	row := q.db.QueryRow(ctx, upsertProgress, arg.UserID, arg.ProblemID)
	var i UserProgress
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProblemID,
		&i.IsSolved,
		&i.Attempts,
		&i.BestTimeMs,
		&i.FirstAttemptedAt,
		&i.LastAttemptedAt,
		&i.SolvedAt,
	)
	return i, err
}
